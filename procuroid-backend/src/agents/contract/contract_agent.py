"""
    ContractAgent takes a JSON dictionary (as generated by QuotationAgent)
    and generates a professional, legally-structured PDF contract.
"""
# How to use ContractAgent:
# 1. Load JSON file: agent = ContractAgent.from_json_file("contract_data.json")
# 2. Generate PDF: pdf_path = agent.generate_contract_pdf()
# 3. Print path: print(pdf_path)

from typing import Dict, Any
from fpdf import FPDF
import json
import datetime
import os
import re

class ContractAgent:
    """
    ContractAgent generates professional PDF contracts from contract data.
    Can be initialized with contract data or data can be provided when generating PDF.
    """
    def __init__(self, contract_json: Dict[str, Any] = None):
        """
        Initialize ContractAgent with optional contract data.
        
        Args:
            contract_json: Optional dictionary containing contract data.
                          If not provided, must be passed to generate_contract_pdf().
        """
        self.data = contract_json or {}

    def _format_date(self, date_str: str) -> tuple:
        """
        Converts YYYY-MM-DD to formatted date tuple (day, month, year).
        Handles empty strings and invalid date formats gracefully.
        """
        if not date_str or not isinstance(date_str, str):
            return ("___", "___", "___")
        
        try:
            date_obj = datetime.datetime.strptime(date_str.strip(), "%Y-%m-%d")
            day = date_obj.strftime("%d").lstrip('0') or '1'
            month = date_obj.strftime("%B")
            year = date_obj.strftime("%Y")
            return (day, month, year)
        except ValueError:
            # Try alternative date formats
            alternative_formats = ["%Y/%m/%d", "%d-%m-%Y", "%d/%m/%Y", "%B %d, %Y", "%b %d, %Y"]
            for fmt in alternative_formats:
                try:
                    date_obj = datetime.datetime.strptime(date_str.strip(), fmt)
                    day = date_obj.strftime("%d").lstrip('0') or '1'
                    month = date_obj.strftime("%B")
                    year = date_obj.strftime("%Y")
                    return (day, month, year)
                except ValueError:
                    continue
            # If all formats fail, return placeholder
            return ("___", "___", "___")
        except Exception as e:
            # Catch any other unexpected errors
            print(f"Warning: Unexpected error parsing date '{date_str}': {e}")
            return ("___", "___", "___")

    def _split_text(self, pdf: FPDF, text: str, max_width: float) -> list:
        """
        Splits text into lines that fit within max_width using FPDF's width calculation.
        Handles extremely long words by breaking them if necessary (e.g., URLs).
        """
        if not text:
            return [""]
        
        words = text.split()
        if not words:
            return [text]
        
        lines = []
        current_line = []
        
        for word in words:
            # Check if a single word is too long
            word_width = pdf.get_string_width(word)
            
            # If word alone exceeds max_width, break it
            if word_width > max_width:
                # Flush current line if it has content
                if current_line:
                    lines.append(' '.join(current_line))
                    current_line = []
                
                # Break long word at reasonable points (hyphens, underscores, or force break)
                if len(word) > 50:
                    # Try to break at punctuation first
                    parts = re.split(r'([-/_])', word)
                    broken_parts = []
                    current_part = ""
                    
                    for part in parts:
                        test_part = current_part + part
                        if pdf.get_string_width(test_part) <= max_width:
                            current_part = test_part
                        else:
                            if current_part:
                                broken_parts.append(current_part)
                            current_part = part
                    
                    if current_part:
                        broken_parts.append(current_part)
                    
                    # If breaking didn't help, force break every 40 characters
                    if not broken_parts or pdf.get_string_width(broken_parts[0]) > max_width:
                        broken_parts = [word[i:i+40] for i in range(0, len(word), 40)]
                    
                    # Add broken parts as separate lines
                    for part in broken_parts:
                        if part:
                            lines.append(part)
                else:
                    # Word is long but manageable - add it (may slightly overflow)
                    lines.append(word)
                continue
            
            # Normal word processing
            test_line = ' '.join(current_line + [word])
            width = pdf.get_string_width(test_line)
            
            if width > max_width and current_line:
                lines.append(' '.join(current_line))
                current_line = [word]
            else:
                current_line.append(word)
        
        if current_line:
            lines.append(' '.join(current_line))
        
        return lines if lines else [text]

    def generate_contract_pdf(self, contract_data: Dict[str, Any] = None, output_path: str = None) -> str:
        """
        Generates a professional PDF contract and returns its file path.
        
        Args:
            contract_data: Optional contract data dictionary. If provided, overrides self.data.
                          If not provided, uses self.data from initialization.
            output_path: Optional output file path. If not provided, generates unique filename.
        
        Returns:
            Absolute path to the generated PDF file.
        """
        # Use provided contract_data or fall back to self.data
        data = contract_data if contract_data is not None else self.data
        
        if not data:
            raise ValueError("Contract data is required. Provide it in __init__ or to generate_contract_pdf()")
        
        pdf = FPDF(format='A4')
        pdf.set_auto_page_break(auto=True, margin=20)
        pdf.add_page()
        
        # Get contract data
        c = data.get("contract_data", {})
        buyer = data.get("buyer_company", {})
        supplier = data.get("supplier_company", {})
        prod = data.get("product_details", {})
        terms = data.get("contract_terms", {})
        deliver = data.get("delivery_information", {})
        
        # Replace [Product Name] placeholder if present
        contract_title = c.get("contract_title", "SUPPLIER AGREEMENT")
        if "[Product Name]" in contract_title:
            product_name = prod.get("product_name", "")
            contract_title = contract_title.replace("[Product Name]", product_name)
        
        # Format date
        date_str = c.get("date_of_agreement", "")
        day, month, year = self._format_date(date_str)
            
        # Main Title
        pdf.set_font('Arial', 'B', 16)
        pdf.cell(0, 12, contract_title.upper(), ln=1, align='C')
        pdf.ln(5)
        
        # Agreement Header
        pdf.set_font('Arial', '', 11)
        agreement_text = f'THIS AGREEMENT (the "Agreement") is made this {day} day of {month}, {year} (the "Effective Date").'
        for line in self._split_text(pdf, agreement_text, 170):
            pdf.cell(0, 6, line, ln=1)
        pdf.ln(3)
        pdf.cell(0, 6, "BETWEEN:", ln=1)
        pdf.ln(2)
        
        # Parties Section
        pdf.set_font('Arial', '', 10)
        buyer_name = buyer.get("name", "[BUYER COMPANY NAME]")
        buyer_reg = buyer.get("registration_number", "[REGISTRATION NUMBER]")
        buyer_addr = buyer.get("address", "[ADDRESS]")
        buyer_state = self._extract_state(buyer_addr)
        
        supplier_name = supplier.get("name", "[SUPPLIER COMPANY NAME]")
        supplier_reg = supplier.get("registration_number", "[REGISTRATION NUMBER]")
        supplier_addr = supplier.get("address", "[ADDRESS]")
        supplier_state = self._extract_state(supplier_addr)
        
        # Customer (Buyer)
        pdf.cell(0, 5, f'(1) {buyer_name}, a company incorporated in {buyer_state} with registration number', ln=1)
        pdf.cell(0, 5, f'    {buyer_reg} and whose registered office is at {buyer_addr} (the "Customer"); and', ln=1)
        pdf.ln(2)
        
        # Supplier
        pdf.cell(0, 5, f'(2) {supplier_name}, a company incorporated in {supplier_state} with registration number', ln=1)
        pdf.cell(0, 5, f'    {supplier_reg} and whose registered office is at {supplier_addr} (the "Supplier").', ln=1)
        pdf.ln(5)
        
        # Section 1: GOODS AND SERVICES
        self._add_section(pdf, "1. GOODS AND SERVICES", bold=True)
        
        pdf.set_font('Arial', '', 10)
        pdf.cell(0, 5, '1.1 The Supplier shall provide the goods (the "Goods") as described in Section 1.2', ln=1)
        pdf.cell(0, 5, '    in accordance with the terms and conditions set out in this Agreement.', ln=1)
        pdf.ln(2)
        
        pdf.cell(0, 5, '1.2 The Goods to be provided by the Supplier include:', ln=1)
        pdf.ln(2)
        
        product_desc = f"{prod.get('product_name', '')} ({prod.get('sku', '')})"
        if prod.get('description'):
            product_desc += f": {prod.get('description', '')}"
        
        pdf.set_font('Arial', '', 10)
        for line in self._split_text(pdf, product_desc, 165):
            pdf.cell(5, 5, '', ln=0)  # Indent
            pdf.cell(0, 5, line, ln=1)
        
        pdf.ln(1)
        pdf.cell(5, 5, '', ln=0)
        pdf.cell(0, 5, f"Quantity: {prod.get('unit_quantity', '')} {prod.get('unit_of_measure', '')}", ln=1)
        pdf.cell(5, 5, '', ln=0)
        pdf.cell(0, 5, f"Unit Price: {prod.get('currency', 'USD')} {prod.get('agreed_unit_price', '0.00'):,.2f}", ln=1)
        pdf.cell(5, 5, '', ln=0)
        pdf.cell(0, 5, f"Total Contract Value: {prod.get('currency', 'USD')} {prod.get('total_contract_value', '0.00'):,.2f}", ln=1)
        pdf.ln(3)
        
        # Section 2: PAYMENT
        self._add_section(pdf, "2. PAYMENT", bold=True)
        
        pdf.set_font('Arial', '', 10)
        pdf.cell(0, 5, '2.1 The Customer shall pay the Supplier for the Goods in accordance with the following terms:', ln=1)
        pdf.ln(2)
        
        payment_terms = terms.get("payment_terms", "Payment terms to be specified.")
        pdf.set_font('Arial', '', 10)
        for line in self._split_text(pdf, payment_terms, 165):
            pdf.cell(5, 5, '', ln=0)
            pdf.cell(0, 5, line, ln=1)
        
        pdf.ln(1)
        pdf.cell(5, 5, '', ln=0)
        pdf.cell(0, 5, f"Total Amount: {prod.get('currency', 'USD')} {prod.get('total_contract_value', '0.00'):,.2f}", ln=1)
        pdf.ln(3)
        
        # Section 3: DELIVERY
        self._add_section(pdf, "3. DELIVERY", bold=True)
        
        pdf.set_font('Arial', '', 10)
        pdf.cell(0, 5, '3.1 The Supplier shall deliver the Goods to the following address:', ln=1)
        pdf.ln(2)
        
        shipping_addr = deliver.get("shipping_address", "")
        delivery_type = deliver.get("delivery_type", "")
        delivery_date = deliver.get("required_delivery_date", "")
        inspection_days = deliver.get("inspection_period_days", "")
        penalty = deliver.get("late_delivery_penalty", "")
        
        pdf.cell(5, 5, '', ln=0)
        for line in self._split_text(pdf, shipping_addr, 165):
            pdf.cell(0, 5, line, ln=1)
        pdf.ln(1)
        
        pdf.cell(0, 5, f'3.2 Delivery Type: {delivery_type}', ln=1)
        pdf.cell(0, 5, f'3.3 Required Delivery Date: {delivery_date}', ln=1)
        pdf.cell(0, 5, f'3.4 Inspection Period: {inspection_days} days from delivery', ln=1)
        if penalty:
            pdf.cell(0, 5, f'3.5 Late Delivery Penalty: {penalty}', ln=1)
        pdf.ln(3)
        
        # Section 4: WARRANTY
        self._add_section(pdf, "4. WARRANTY", bold=True)
        
        warranty = terms.get("warranty_period", "Warranty terms to be specified.")
        pdf.set_font('Arial', '', 10)
        pdf.cell(0, 5, '4.1 The Supplier warrants that:', ln=1)
        pdf.ln(2)
        pdf.cell(5, 5, '', ln=0)
        pdf.cell(0, 5, f'(a) The Goods will conform to the specifications and descriptions provided;', ln=1)
        pdf.cell(5, 5, '', ln=0)
        pdf.cell(0, 5, f'(b) {warranty}', ln=1)
        pdf.ln(3)
        
        # Section 5: LIABILITY
        self._add_section(pdf, "5. LIABILITY", bold=True)
        
        pdf.set_font('Arial', '', 10)
        pdf.cell(0, 5, '5.1 Neither party excludes or limits its liability for: (a) death or personal injury', ln=1)
        pdf.cell(0, 5, '    caused by its negligence; (b) fraud or fraudulent misrepresentation; or (c) any', ln=1)
        pdf.cell(0, 5, '    other liability that cannot be excluded or limited under applicable law.', ln=1)
        pdf.ln(2)
        
        indemnification = terms.get("indemnification_limit", "Capped at the total contract value.")
        pdf.cell(0, 5, '5.2 Subject to Clause 5.1, the Supplier\'s total liability arising under or in', ln=1)
        pdf.cell(0, 5, '    connection with this Agreement, whether in contract, tort (including negligence),', ln=1)
        pdf.cell(0, 5, '    breach of statutory duty, or otherwise, shall not exceed the total fees paid by', ln=1)
        pdf.cell(0, 5, '    the Customer to the Supplier under this Agreement.', ln=1)
        pdf.ln(2)
        
        for line in self._split_text(pdf, f"5.3 {indemnification}", 170):
            pdf.cell(0, 5, line, ln=1)
        pdf.ln(3)
        
        # Section 6: INTELLECTUAL PROPERTY RIGHTS
        self._add_section(pdf, "6. INTELLECTUAL PROPERTY RIGHTS", bold=True)
        
        pdf.set_font('Arial', '', 10)
        pdf.cell(0, 5, '6.1 All intellectual property rights in the Goods provided under this Agreement', ln=1)
        pdf.cell(0, 5, '    shall remain the property of the Supplier, unless otherwise agreed in writing.', ln=1)
        pdf.ln(3)
        
        # Section 7: CONFIDENTIALITY
        self._add_section(pdf, "7. CONFIDENTIALITY", bold=True)
        
        pdf.set_font('Arial', '', 10)
        pdf.cell(0, 5, '7.1 Each party agrees to keep the other party\'s Confidential Information', ln=1)
        pdf.cell(0, 5, '    confidential and to use it strictly for the performance of this Agreement.', ln=1)
        pdf.ln(3)
        
        # Section 8: TERM AND TERMINATION
        self._add_section(pdf, "8. TERM AND TERMINATION", bold=True)
        
        termination = terms.get("termination_clause", "Standard termination with 60-day written notice; immediate termination for material breach.")
        pdf.set_font('Arial', '', 10)
        pdf.cell(0, 5, '8.1 This Agreement shall commence on the Effective Date and shall continue', ln=1)
        pdf.cell(0, 5, '    until terminated in accordance with this Agreement.', ln=1)
        pdf.ln(2)
        
        for line in self._split_text(pdf, f'8.2 {termination}', 170):
            pdf.cell(0, 5, line, ln=1)
        pdf.ln(3)
        
        # Section 9: GOVERNING LAW AND JURISDICTION
        self._add_section(pdf, "9. GOVERNING LAW AND JURISDICTION", bold=True)
        
        governing_law = terms.get("governing_law", "State of Georgia")
        dispute_resolution = terms.get("dispute_resolution", "Binding arbitration in Atlanta, GA.")
        
        pdf.set_font('Arial', '', 10)
        pdf.cell(0, 5, f'9.1 This Agreement and any dispute or claim arising out of or in connection', ln=1)
        pdf.cell(0, 5, f'    with it shall be governed by and construed in accordance with the law of {governing_law}.', ln=1)
        pdf.ln(2)
        
        for line in self._split_text(pdf, f'9.2 {dispute_resolution}', 170):
            pdf.cell(0, 5, line, ln=1)
        pdf.ln(5)
        
        # Signatures Section
        pdf.set_font('Arial', 'B', 11)
        pdf.cell(0, 8, "IN WITNESS WHEREOF, the parties have executed this Agreement as of the Effective Date.", ln=1, align='C')
        pdf.ln(8)
        
        # Signature blocks
        buyer_contact = buyer.get("contact_information", {})
        supplier_contact = supplier.get("contact_information", {})
        
        # Company names
        pdf.set_font('Arial', 'B', 10)
        pdf.cell(90, 6, buyer_name, ln=0, align='L')
        pdf.cell(0, 6, supplier_name, ln=1, align='L')
        pdf.ln(10)
        
        # Signature blocks with lines right after "Signatory:" text
        pdf.set_font('Arial', '', 9)
        pdf.set_line_width(0.5)
        
        # Get starting position
        start_x_left = pdf.get_x()
        y_pos = pdf.get_y()
        
        # Left signature block (Buyer) - Write "Signatory:" and draw line immediately after
        signatory_text = "Signatory: "
        signatory_width = pdf.get_string_width(signatory_text)
        pdf.cell(signatory_width, 5, signatory_text, ln=0, align='L')
        
        # Draw line right after "Signatory:" text, extending to end of left column
        line_start_x = pdf.get_x() + 1  # Small gap after text
        line_end_x = start_x_left + 90  # End of left column
        pdf.line(line_start_x, y_pos + 4, line_end_x, y_pos + 4)
        
        # Right signature block (Supplier) - Position at right column
        start_x_right = 120  # Start of right column
        pdf.set_xy(start_x_right, y_pos)
        pdf.cell(signatory_width, 5, signatory_text, ln=0, align='L')
        
        # Draw line right after "Signatory:" text for right column
        line_start_x_right = pdf.get_x() + 1
        line_end_x_right = 190  # End of page width
        pdf.line(line_start_x_right, y_pos + 4, line_end_x_right, y_pos + 4)
        
        # Move to next line
        pdf.set_xy(start_x_left, y_pos + 8)
        pdf.ln(2)
        
        # Names
        pdf.set_font('Arial', '', 9)
        pdf.cell(90, 5, f"Name: {buyer_contact.get('buyer_name', '')}", ln=0, align='L')
        pdf.cell(0, 5, f"Name: {supplier_contact.get('supplier_name', '')}", ln=1, align='L')
        pdf.ln(3)
        
        # Titles
        pdf.cell(90, 5, f"Title: {buyer_contact.get('title', '')}", ln=0, align='L')
        pdf.cell(0, 5, f"Title: {supplier_contact.get('title', '')}", ln=1, align='L')
        pdf.ln(3)
        
        # Emails
        pdf.cell(90, 5, f"Email: {buyer_contact.get('email', '')}", ln=0, align='L')
        pdf.cell(0, 5, f"Email: {supplier_contact.get('email', '')}", ln=1, align='L')
        pdf.ln(3)
        
        # Date lines - draw lines right after "Date:" text
        start_x_left = pdf.get_x()
        y_pos = pdf.get_y()
        
        # Left date block
        date_text = "Date: "
        date_width = pdf.get_string_width(date_text)
        pdf.cell(date_width, 5, date_text, ln=0, align='L')
        
        # Draw line right after "Date:" text
        line_start_x = pdf.get_x() + 1
        line_end_x = start_x_left + 90
        pdf.line(line_start_x, y_pos + 4, line_end_x, y_pos + 4)
        
        # Right date line
        start_x_right = 120
        pdf.set_xy(start_x_right, y_pos)
        pdf.cell(date_width, 5, date_text, ln=0, align='L')
        line_start_x_right = pdf.get_x() + 1
        line_end_x_right = 190
        pdf.line(line_start_x_right, y_pos + 4, line_end_x_right, y_pos + 4)
        
        # Move to next line
        pdf.set_xy(start_x_left, y_pos + 8)
        pdf.ln(2)
        
        # File output with unique suffix to prevent overwrites
        if not output_path:
            base = c.get('order_reference_id', 'contract')
            safe_base = "".join([x if x.isalnum() or x in ('-', '_') else '_' for x in str(base)])
            # Get current timestamp once for consistency
            now = datetime.datetime.now()
            today = now.strftime('%Y%m%d')
            timestamp = now.strftime('%H%M%S')
            # Add microsecond suffix to ensure uniqueness
            unique_suffix = now.strftime('%f')[:4]  # First 4 digits of microseconds
            output_path = f"{safe_base}_contract_{today}_{timestamp}_{unique_suffix}.pdf"
            
            # If file still exists (unlikely but possible), append counter
            counter = 1
            original_path = output_path
            while os.path.exists(output_path):
                name_part = original_path.rsplit('.', 1)[0]
                output_path = f"{name_part}_v{counter}.pdf"
                counter += 1
                if counter > 100:  # Safety limit
                    break
        
        pdf.output(output_path)
        return os.path.abspath(output_path)
    
    def _extract_state(self, address: str) -> str:
        """
        Extracts state/country from address.
        Handles both US addresses and international addresses.
        For international addresses, extracts country or province/state name.
        """
        if not address or not isinstance(address, str):
            return "[STATE/COUNTRY]"
        
        # US States mapping
        us_states = {
            'AL': 'Alabama', 'AK': 'Alaska', 'AZ': 'Arizona', 'AR': 'Arkansas',
            'CA': 'California', 'CO': 'Colorado', 'CT': 'Connecticut', 'DE': 'Delaware',
            'FL': 'Florida', 'GA': 'Georgia', 'HI': 'Hawaii', 'ID': 'Idaho',
            'IL': 'Illinois', 'IN': 'Indiana', 'IA': 'Iowa', 'KS': 'Kansas',
            'KY': 'Kentucky', 'LA': 'Louisiana', 'ME': 'Maine', 'MD': 'Maryland',
            'MA': 'Massachusetts', 'MI': 'Michigan', 'MN': 'Minnesota', 'MS': 'Mississippi',
            'MO': 'Missouri', 'MT': 'Montana', 'NE': 'Nebraska', 'NV': 'Nevada',
            'NH': 'New Hampshire', 'NJ': 'New Jersey', 'NM': 'New Mexico', 'NY': 'New York',
            'NC': 'North Carolina', 'ND': 'North Dakota', 'OH': 'Ohio', 'OK': 'Oklahoma',
            'OR': 'Oregon', 'PA': 'Pennsylvania', 'RI': 'Rhode Island', 'SC': 'South Carolina',
            'SD': 'South Dakota', 'TN': 'Tennessee', 'TX': 'Texas', 'UT': 'Utah',
            'VT': 'Vermont', 'VA': 'Virginia', 'WA': 'Washington', 'WV': 'West Virginia',
            'WI': 'Wisconsin', 'WY': 'Wyoming', 'DC': 'District of Columbia'
        }
        
        # Common country names (for international addresses)
        common_countries = [
            'United Kingdom', 'UK', 'Canada', 'Australia', 'Germany', 'France', 'Italy',
            'Spain', 'Netherlands', 'Belgium', 'Switzerland', 'Austria', 'Sweden',
            'Norway', 'Denmark', 'Finland', 'Poland', 'Portugal', 'Greece', 'Ireland',
            'Japan', 'China', 'India', 'Brazil', 'Mexico', 'Argentina', 'South Korea',
            'Singapore', 'Hong Kong', 'New Zealand', 'South Africa', 'United States',
            'USA', 'US'
        ]
        
        # Split address by comma
        parts = [part.strip() for part in address.split(',')]
        
        if len(parts) < 2:
            # If no commas, try to extract from the end (might be single line address)
            # Return a generic placeholder or the address itself if it's short
            if len(address) < 50:
                return address
            return "[STATE/COUNTRY]"
        
        # For US addresses: typically "City, State ZIP" or "City, State, ZIP"
        # State is usually second-to-last or last part (before ZIP)
        for i in range(len(parts) - 1, -1, -1):
            part = parts[i].strip().upper()
            
            # Check if it's a US state abbreviation
            if part in us_states:
                return us_states[part]
            
            # Check if it contains a US state name
            for abbr, name in us_states.items():
                if name.upper() in part.upper() or part.upper() in name.upper():
                    return name
            
            # Check if it's a ZIP code pattern (5 digits or 5+4 format)
            if re.match(r'^\d{5}(-\d{4})?$', part):
                # Previous part is likely the state
                if i > 0:
                    state_part = parts[i - 1].strip().upper()
                    if state_part in us_states:
                        return us_states[state_part]
                    for abbr, name in us_states.items():
                        if name.upper() in state_part.upper():
                            return name
        
        # For international addresses: typically "City, Province/State, Country"
        # Country is usually the last part
        last_part = parts[-1].strip()
        
        # Check if last part is a country
        for country in common_countries:
            if country.upper() in last_part.upper() or last_part.upper() in country.upper():
                # If second-to-last exists, it might be a province/state
                if len(parts) >= 3:
                    province = parts[-2].strip()
                    if province and len(province) < 50:  # Reasonable length for a province/state
                        return f"{province}, {country}"
                return country
        
        # If we have multiple parts, use second-to-last as state/province
        # and last as country (common international format)
        if len(parts) >= 2:
            # Return the second-to-last part (likely state/province) if it exists
            province_state = parts[-2].strip()
            if province_state and len(province_state) < 50:
                # Check if last part looks like a country (not a ZIP code)
                last_part_clean = parts[-1].strip()
                if not re.match(r'^\d+$', last_part_clean):  # Not just digits
                    return f"{province_state}, {last_part_clean}"
                return province_state
        
        # Fallback: return last part if it's reasonable
        if parts:
            last = parts[-1].strip()
            if last and len(last) < 50:
                return last
        
        return "[STATE/COUNTRY]"
    
    def _add_section(self, pdf: FPDF, title: str, bold: bool = True):
        """Adds a section header with bold formatting and underline"""
        pdf.ln(2)
        if bold:
            pdf.set_font('Arial', 'B', 11)
        else:
            pdf.set_font('Arial', '', 11)
        
        # Get the starting x position and y position before writing
        start_x = pdf.get_x()
        y_before = pdf.get_y()
        
        # Write the title
        pdf.cell(0, 8, title, ln=1)
        
        # Calculate the width of the title text
        title_width = pdf.get_string_width(title)
        
        # Draw underline right under the text (starting from left margin)
        y_after = pdf.get_y()
        pdf.set_line_width(0.5)
        pdf.line(start_x, y_before + 7, start_x + title_width, y_before + 7)
        
        pdf.ln(2)

    def generate_contract(self, contract_data: Dict[str, Any] = None, output_path: str = None) -> dict:
        """
        Alias for generate_contract_pdf() for compatibility with RootAgent.
        Returns a dictionary with contract information instead of just the path.
        
        Args:
            contract_data: Optional contract data dictionary.
            output_path: Optional output file path.
        
        Returns:
            Dictionary containing contract information including file path.
        """
        try:
            pdf_path = self.generate_contract_pdf(contract_data, output_path)
            return {
                "status": "success",
                "contract_path": pdf_path,
                "message": "Contract PDF generated successfully"
            }
        except Exception as e:
            return {
                "status": "error",
                "error": str(e),
                "message": "Failed to generate contract PDF"
            }
    
    @staticmethod
    def from_json_file(json_path: str) -> 'ContractAgent':
        """
        Loads a contract from a JSON file path.
        """
        with open(json_path, 'r') as f:
            data = json.load(f)
        return ContractAgent(data)

if __name__ == "__main__":
    import sys
    if len(sys.argv) < 2:
        print("Usage: python contract_agent.py <path_to_json_file>")
        sys.exit(1)

    json_path = sys.argv[1]
    print(f"Loading contract data from {json_path}...")

    agent = ContractAgent.from_json_file(json_path)
    output_path = agent.generate_contract_pdf()

    print(f"âœ… Contract PDF generated successfully: {output_path}")
